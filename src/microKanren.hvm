// x ∈ Var
// s ∈ Symbol
// b ∈ Bool
// Term ::= x | s | b | [] | (Pair Term Term)

// UTILS
// -----

// (If U32 a a) : a
(If 0 t f) = f
(If 1 t f) = t

// STATE
// -----

// Holds the goal state comprised of the substitution list and the variable counter
// (State.Empty) : (State Subst U32)
(State.Empty) = (State [] 0)
// (State.Unit Subst U32) : (State Subst U32)
(State.Unit s c) = (State s c)

// STREAM
// ------

// (Stream.Empty) : List (State Subst U32)
(Stream.Empty) = Nil
// (Stream.Unit State) : List (State Subst U32)
(Stream.Unit state) = (Cons state Stream.Empty)


// bind is required in the implementation of conj.
// When a goal constructed from conj is invoked, the goal g1
// is invoked on the current state; the result of this invocation
// is a nite stream (represented as a proper nite list).

// Bind : Stream -> (State -> Stream) -> Stream
(Bind []          fn) = []
(Bind (Cons x xs) fn) = (MPlus (fn x) (Bind xs fn))
// (Bind 0           fn) = 0
// (Bind x           fn) = (fn x)
// (Bind (Some n)    fn) = (fn n)
// (Bind None        fn) =

// MonadPlus
// ---------
// The MonadPlus interface provides two primitives, mzero and
// mplus, for expressing backtracking computations.

// The mplus operator is responsible for merging streams.
// In a goal constructed from disj, the resulting stream
// contains the states that result from success of either
// of the two goals.

// MPlus is a disjunction of goals
// MPlus : Stream -> Stream -> Stream
(MPlus list        []  ) = list
(MPlus []          list) = list
(MPlus (Cons x xs) list) = (Cons x (MPlus list xs)) // invert list to interleave
// (Cons x (MPlus xs stream))

(Some n fn) = (fn n)
(None fn) = (fn)

// Take `n` items from the list
(Take n Nil        ) = Nil
(Take 0 _          ) = Nil
(Take n (Cons x xs)) = (Cons x (Take (- n 1) xs))

// // Just a test (returns 2)
// Main = (Head (Tail (Tail Nats)))


// SUBSTITUION
// -----------

// : List Binding
(Subst.Unit var val) = (ExtSubst Nil var val)
// subst: (s: List Binding) -> (var: LVar) -> (val: U32) -> List Binding
(ExtSubst s var val) = (Cons (Pair var val) s)

// #| Occurs: Var x Term x Subst -> Bool |#
//
// (define (occurs? x u s)
//    (cond
//        ((var? u) (eqv? x u))
//        ((pair? u) (or (occurs? x (find (car u) s) s)
//        (occurs? x (find (cdr u) s) s)))
//        (else #f)))
// (Occurs (LVar n) )

// TODO check for circularity

// Find : LVar -> Subst -> (U32 -> <A>) (LVar -> <A>) -> <A>
(Find (LVar n) (Cons (Pair (LVar n2) val) xs)) = (If (== n n2) val (Find (LVar n) xs))
(Find u        subst                         ) = u

// (define (unify u v s)
//     (cond
//         ((eqv? u v) s)
//         ((var? u) (ext-s u v s))
//         ((var? v) (unify v u s))
//         ((and (pair? u) (pair? v))
//             (let ((s (unify (find (car u) s) (find (car v) s) s)))
//             (and s (unify (find (cdr u) s) (find (cdr v) s) s))))
//         (else #f)))
// Unify : Term ⨯ Term ⨯ Subst ⟶ Maybe Subst
(Unify u v s tFn eFn) = (Unify.Go (Find u s) (Find v s) s tFn eFn)
    (Unify.Go (Pair u1 u2) (Pair v1 v2) s thenFn failFn) = (Unify.Go (Find u1 s) (Find v1 s) s λs( (Unify.Go (Find u2 s) (Find v2 s) s λs(s) λs(0)) ) λuλv(0))
    (Unify.Go (LVar u)     (LVar v)     s thenFn failFn) = (If (== u v) (thenFn s) (thenFn (ExtSubst s (LVar u) (LVar v))))
    (Unify.Go (LVar u)     v            s thenFn failFn) = (thenFn (ExtSubst s (LVar u) v))
    (Unify.Go u            (LVar v)     s thenFn failFn) = (Unify (LVar v) u s thenFn failFn) //  (ExtSubst s (LVar v) u)
    (Unify.Go []          []            s thenFn failFn) = (thenFn s)
    (Unify.Go (Cons u us) (Cons v vs)   s thenFn failFn) = (Unify.Go (Find u s) (Find v s) s λs( (Unify.Go (Find us s) (Find vs s) s λs(s) λs(0)) ) λuλv(0))
    (Unify.Go u            v            s thenFn failFn) = (If (== u v) (thenFn s) (failFn u v)) // else False

// GOAL CONSTRUCTORS
// -----------------

// Equal LVar LVar) : (State -> Stream)
(Equal u v) = λstate( (Equal.Go u v state) )
    (Equal.Go u v (State s c)) = (Unify u v s λs( [(State s c)] ) λuλv([]))

(Equal.Test1) = ((Equal 1 1) State.Empty)

// (Fresh (LVar -> (State -> Stream)) : Stream
(Fresh fn) = λstate( (Fresh.Go fn state) )
    (Fresh.Go fn (State s c)) = ((fn (LVar c)) (State s (+ c 1)))

(Fresh2 fn) = (λstate( (Fresh2.Go fn state) ))
    (Fresh2.Go fn (State s c)) = ( (fn (LVar c) (LVar (+ c 1))) (State s (+ c 2)) )

(Fresh3 fn) = (λstate( (Fresh3.Go fn state) ))
    (Fresh3.Go fn (State s c)) = ( (fn (LVar c) (LVar (+ c 1)) (LVar (+ c 2))) (State s (+ c 3)) )


// (Disj (State -> Stream) (State -> Stream)) : (State -> Stream)
(Disj g1 g2) = λstate( (MPlus g1 state) (g2 state) )

// (Conj (State -> Stream) (State -> Stream)) : (State -> Stream)
(Conj g1 g2) = λstate( (Bind (g1 state) g2) )

// (Match (Cons g gs)) = λstate( (g state) )
//     (Match.Go)

// A goal that succeeds.
(Succeed) = (== 1 1)

// A goal that fails
(Fail) = (== 1 0)


(RunMany n fn) = (Take n ((Fresh fn) (State.Empty)))

(RunAll fn) = ((Fresh fn) (State.Empty))

// TESTS
// -----

(Test.Subst0) = []
(Test.Subst1) = (Subst.Unit (LVar 1) 10)
(Test.Subst2) = (ExtSubst Test.Subst1 (LVar 2) 20)
(Test.Subst3) = (ExtSubst Test.Subst2 (LVar 3) 30)

(Test.State0) = (State.Empty)

// > (define (fives x) (disj (≡ x 5) (fives x)))
// > ((call/fresh fives) empty-state)
(Test.Goal0) = (Fresh λx( (Test.Goal.Fives x) ))
    (Test.Goal.Fives x) = (Disj (Equal x 5) (Test.Goal.Fives x))

(Main) =
    // (Test.Subst0) // == []
    // (Test.Subst1) // == [(Pair (LVar 1) 10)
    // (Test.Subst2) // == [(Pair (LVar 2) 20), (Pair (LVar 1) 10)]
    // (Test.Subst3) // == [(Pair (LVar 3) 30), (Pair (LVar 2) 20), (Pair (LVar 1) 10)]

    // (Find (LVar 0) Test.Subst0) // == (LVar 0)
    // (Find (LVar 1) Test.Subst0) // == (LVar 1)
    // (Find (LVar 1) Test.Subst1) // == 10
    // (Find (LVar 2) Test.Subst2) // == 20

    // (Unify (LVar 1) (LVar 1) [])   // == [] there is nothing to unify since they are the same
    // (Unify 10 (LVar 1) [])   // == [(Pair (LVar 1) 10)]
    // (Unify (LVar 1) (LVar 2) Nil)   // == [(Pair (LVar 1) (LVar 2))] add new subst
    // (Unify (LVar 1) (LVar 1) Test.Subst1)   // == [(Pair (LVar 1) 10)] no changes to substitution
    // (Unify (LVar 2) (LVar 2) Test.Subst2)   // == [(Pair (LVar 2) 20), (Pair (LVar 1) 10)] -- no change to subst
    // (Unify 2 4 Test.Subst3)                 // == 0 -- dont unify
    // (Unify (Pair (LVar 4) 50) (Pair 40 (LVar 5)) [])                 // == [(Pair (LVar 5) 50), (Pair (LVar 4) 40)] add new subst
    // (Unify [] [] Test.Subst3)                 // == [(Pair (LVar 3) 30), (Pair (LVar 2) 20), (Pair (LVar 1) 10)] -- subst unchanged
    // (Unify [(LVar 4)] [40] [])                 // == [(Pair (LVar 4) 40)] add new subst
    // (Unify [(LVar 4), (LVar 5)] [40, 50] [])                 // == [(Pair (LVar 4) 40)] add new subst

    // ((Equal (LVar 1) (LVar 1)) (State.Empty)) // Stream -- [(State [] 0)]
    // ((Equal (LVar 1) 10) (State.Empty)) // Stream -- [(State [(Pair (LVar 1) 10)] 0)]
    ((Equal 1 2) (State.Empty)) // Stream -- [(State [(Pair (LVar 1) 10)] 0)]

    // Test goals
    // ----------
    // (Test.Goal0) // diverges ...
    // ((call/fresh (lambda (q) (≡ q 5))) empty-state) ; #(0)5
    // ((Fresh λx( (Equal x 5) )) (State.Empty))
    // ((Fresh2 λxλy(Equal y 5)) (State.Empty))
    // ((Fresh3 λxλyλz(Equal z 5)) (State.Empty))
    // ((Fresh3 λxλyλz(Conj (Equal x z) (Equal x z))) (State.Empty))
    // (RunMany 4 λx( (Equal x 5) ))
    // (RunAll λx( (Equal x 5) ))
    // (Run 2 λx( (Test.Goal.Fives x) )) // diverges!!
    // (Equal.Test1)

// Goal :: State ⟶ Stream
// State :: Subst ⨯ Nat
// Stream :: Mature | Immature
// Mature :: () | State ⨯ Stream
// Immature :: Unit ⟶ Stream
